<?php
/**
 * @file
 * Hook implementations and API functions for drafty module.
 */

/**
 * Implements hook_entity_presave().
 */
function drafty_entity_presave($entity, $type) {
  if (empty($entity->is_new) && !empty($entity->is_draft_revision)) {
    drafty()->setScope($entity->is_draft_revision);
    // Since this is a draft revision, after saving we want the current,
    // published revision to remain in place in the base entity table and
    // field_data_*() tables. Set the revision to publish once the draft entity
    // has been written to the database.
    list($id) = entity_extract_ids($type, $entity);
    $vid = drafty()->getPublishedRevisionId($type, $id);
    drafty()->setRevisionToBePublished($type, $id, $vid);
  }
}

/**
 * Implements hook_entity_update().
 */
function drafty_entity_update($entity, $type) {
  // Doing this in hook_entity_update() so that the entire process is
  // completed within entity saving. However this results in two entity saves
  // within entity insert. The other option is hook_exit(), which is not better,
  // since for example that would happen outside the transaction.
  drafty()->restorePublishedRevisions();
  drafty()->removeScope();
}

/**
 * Implements hook_entity_insert().
 */
function drafty_entity_insert($entity, $type) {
  // Remove any drafty scope set during revision saving so that it is clear for
  // the next save.
  drafty()->removeScope();
}

/**
 * Factory function for the DraftyTracker class.
 */
function drafty() {
  $tracker = &drupal_static(__FUNCTION__);
  if (!isset($tracker)) {
    $tracker = new Drafty();
  }
  return $tracker;
}

/**
 * Handles tracking, selecting and publishing revisions.
 */
class Drafty {

  /**
   * A list of entity types, ids and version IDs to be published.
   */
  protected $revisionsToPublish = array();

  /**
   * The revision scope. Draft is TRUE, default revision is FALSE.
   */
  protected $scope = NULL;

  /**
   * Set the current scope.
   *
   * @param (bool) $scope
   *   TRUE if a draft, FALSE if default revision.
   */
  public function setScope($scope) {
    $this->scope = $scope;
  }

  /**
   * Get the current scope.
   */
  public function getScope() {
    return $this->scope;
  }

  /**
   * Get the current scope.
   */
  public function hasScope() {
    return isset($this->scope);
  }

  /**
   * Reset the scope.
   */
  public function removeScope() {
    $this->scope = NULL;
  }

  /**
   * Get the current published revision for an entity.
   *
   * @param $type
   *   The entity type.
   * @param $id
   *   The entity ID.
   *
   * @return A version ID.
   */
  public function getPublishedRevisionId($type, $id) {
    $info = entity_get_info();
    // Get the version ID of the published revision directly from the database.
    // It is not possible to rely on $entity->original here since that does not
    // guarantee being the published revision. Also avoid loading the entity
    // because we may be in the process of saving it.
    $vid = db_select($info[$type]['base table'], 'base')
      ->condition($info[$type]['entity keys']['id'], $id)
      ->fields('base', array($info[$type]['entity keys']['revision']))
      ->execute()->fetchField();

    return $vid;
  }

  /**
   * Add a revision to be published to the tracker.
   *
   * @param $type
   *   The entity type.
   * @param $id
   *   The entity ID.
   * @param $vid
   *   The entity version ID.
   *
   * @return $this
   */
  public function setRevisionToBePublished($type, $id, $vid) {
    // Only one revision can be published during a request, so just overwrite
    // and for now last one wins.
    $this->revisionsToPublish[$type][$id] = $vid;

    return $this;
  }

  /**
   * Publish a revision.
   *
   * @param $type
   *   The entity type.
   * @param $vid
   *   The entity version ID.
   *
   * @return The newly published revision.
   */
  function publishRevision($type, $vid) {
    $revision = entity_revision_load($type, $vid);
    $revision->is_draft_revision = FALSE;
    return $this->saveRevisionAsNew($type, $revision);
  }

  /**
   * Save a revision as new.
   *
   * @param $type
   *   The entity type.
   * @param $revision
   *   An entity object.
   *
   * @return The newly saved revision.
   */
  public function saveRevisionAsNew($type, $revision) {
    // Set scope to the value of is_draft_revision so that any recursively
    // triggered entity_save() will not be concerned about draft tracking.
    drafty()->setScope($revision->is_draft_revision);
    $revision->revision = TRUE;
    entity_save($type, $revision);
    return $revision;
  }

  /**
   * Publish revisions previously set with setRevisionToBePublished().
   */
  public function restorePublishedRevisions() {
    foreach ($this->revisionsToPublish as $type => $value) {
      foreach ($value as $id => $vid) {
        unset($this->revisionsToPublish[$type][$id]);
        $this->publishRevision($type, $vid);
        // Now that the revision is deleted, there are two identical copies of
        // the revision in the system. The original 'draft' revision and the
        // newly saved published revision. Delete the draft revision now since
        // it's not needed.
        // @todo: make this configurable?
        // @todo: when restoring a published revision, should the revision
        // timestamp be set to the old value?
        // @todo: move this to a queue since the deletion doesn't strictly have
        // to happen inline.
        entity_revision_delete($type, $vid);
      }
    }
  }
}
